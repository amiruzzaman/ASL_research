---
import Layout from "../layouts/Layout.astro";
import SpinnerOverlay from "../components/SpinnerOverlay.astro";
---

<Layout class="app" title="Record ASL Word/Phrase">
  <div class="io-pane">
    <SpinnerOverlay class="spin-overlay" id="spinner"> Processing </SpinnerOverlay>
    <video id="video-output"></video>
    <div style="display: none;" id="preview-parent"></div>
  </div>
  <div class="interface">
    <div id="complete-section" style="display: none;">
      <label>Word Name: <input name="word-name" id="name-input" value="word" /></label>
      <div class="word-actions colrow-sm">
        <a id="download-link" href="about:blank">Download Data</a>
        <button id="create-word">Save To Library</button>
      </div>
    </div>
    <button data-recording="false" id="record">Start Recording</button>
  </div>
  <p>
    Record some ASL by clicking the "Start Recording" button above. After recording you'll be shown
    a preview of your sign and have the option to save it to a local file. Place this file in the <code
      >words</code
    > directory to have it available in the <a href="/e2a">English to ASL</a> page.
  </p>
</Layout>

<style>
  span#placeholder-instructions {
    text-align: center;
    font-size: var(--2);
  }

  span.arrow {
    font-size: var(--4);
  }

  label {
    text-align: center;
  }

  .app {
    display: flex;
    flex-direction: column;
    gap: var(--2);
  }

  .interface {
    display: flex;
    flex-direction: row;
    justify-content: center;
  }

  .io-pane {
    height: 40vh;
    display: flex;
    align-items: center;
    padding: var(--2);
    /* Hard-coded dark background since in light theme it's hard to see the animation */
    background-color: #14191f;
    border-radius: var(--2);
    position: relative;
  }

  .spin-overlay {
    font-size: var(--3);
  }

  .word-actions {
    display: flex;
    gap: var(--1);
    align-items: center;
  }

  #complete-section {
    display: flex;
    flex-direction: column;
    gap: var(--1);
    align-items: stretch;
  }

  #preview-parent {
    width: 100%;
    height: 100%;
  }

  video {
    height: 100%;
    margin: 0 auto;
    border-radius: var(--1);
  }
</style>

<script>
  import { decodeMultiStream, encode } from "@msgpack/msgpack";
  import {
    type WordData,
    type Frame,
    prepareCanvas,
    renderAsl,
    type TranslationRequest,
  } from "../lib/asl-render";

  const VIDEO_MIME = "video/webm";

  const backendHost = import.meta.env.PUBLIC_BACKEND_HOST ?? "";
  const markEndpoint = `${backendHost}/api/mark`;
  const wordEndpoint = `${backendHost}/api/word`;

  const processVideo = async (rawFrames: Blob[]): Promise<WordData | null> => {
    const resp = await fetch(markEndpoint, {
      method: "POST",
      body: new Blob(rawFrames),
      headers: { "Content-Type": VIDEO_MIME },
    });
    if (resp.ok && resp.body !== null) {
      const frames = [];
      for await (const frame of decodeMultiStream(resp.body)) {
        frames.push(frame as Frame);
      }
      return frames;
    } else {
      // TODO: Error Handle
      console.error(resp);
      return null;
    }
  };

  const ready = () => {
    const videoElem = document.getElementById("video-output")! as HTMLVideoElement;
    const recordButton = document.getElementById("record")! as HTMLButtonElement;
    const downloadLink = document.getElementById("download-link")! as HTMLAnchorElement;
    const previewCanvas = document.getElementById("preview-parent")! as HTMLDivElement;
    const completeSection = document.getElementById("complete-section")! as HTMLDivElement;
    const nameInput = document.getElementById("name-input")! as HTMLInputElement;
    const spinnerElem = document.getElementById("spinner")! as HTMLSpanElement;
    const uploadButton = document.getElementById("create-word")! as HTMLButtonElement;

    let isRecording = false;
    let stopping = false;

    const recordStream: MediaStream | null = null;

    const afterRecord = async (rawData: Blob[]) => {
      recordButton.disabled = true;
      recordButton.style.display = "none";
      videoElem.style.display = "none";
      spinnerElem.dataset.loading = "true";
      const wordData = await processVideo(rawData);
      if (wordData !== null) {
        previewCanvas.style.display = "block";
        const req = {
          words: ["rec"],
          dataMap: { rec: wordData },
        } as TranslationRequest;
        const threeCtx = prepareCanvas(previewCanvas);
        renderAsl(threeCtx, req);
        const msgPackData = new Blob([encode(wordData)]);
        downloadLink.href = URL.createObjectURL(msgPackData);
        downloadLink.download = "word.msgpack";
        spinnerElem.dataset.loading = "false";
        completeSection.style.display = "";
        let wordName = "word";
        nameInput.onkeyup = () => {
          wordName = nameInput.value;
          downloadLink.download = `${wordName}.msgpack`;
        };
        uploadButton.onclick = async () => {
          uploadButton.setAttribute("disabled", "true");
          previewCanvas.style.display = "none";
          spinnerElem.dataset.loading = "true";
          const resp = await fetch(`${wordEndpoint}/${wordName}`, {
            method: "POST",
            body: msgPackData,
            headers: { "Content-Type": "application/x-msgpack" },
          });
          spinnerElem.dataset.loading = "false";
          if (resp.ok) {
            window.alert("New Word Saved");
            window.location.reload();
          } else {
            console.error(`Couldn't Create Word`, resp.status, await resp.text());
            window.alert(`Failed to create word in library: ${resp.status}`);
            uploadButton.removeAttribute("disabled");
          }
        };
      } else {
        console.error("wordData is null!");
      }
    };

    const streamOpened = (stream: MediaStream) => {
      const options = { mimeType: VIDEO_MIME };
      const recordedData: Blob[] = [];
      const recorder = new MediaRecorder(stream, options);
      spinnerElem.dataset.loading = "false";
      videoElem.srcObject = stream;
      videoElem.play();

      const onData = (e: MediaRecorderEventMap["dataavailable"]) => {
        if (e.data.size > 0) {
          recordedData.push(e.data);
        }

        if (stopping && isRecording) {
          recorder.stop();
          stopping = false;
        }
      };

      const onStopped = () => {
        isRecording = false;
        stream.getTracks().forEach((t) => t.stop());
        afterRecord(recordedData);
      };

      recorder.addEventListener("dataavailable", onData);
      recorder.addEventListener("stop", onStopped);
      isRecording = true;

      recorder.start(500);
    };

    recordButton.onclick = () => {
      if (isRecording) {
        recordButton.innerText = "Start Recording";
        recordButton.dataset["recording"] = "false";
        stopping = true;
      } else {
        recordButton.dataset["recording"] = "true";
        recordButton.innerText = "Stop Recording";
        spinnerElem.dataset.loading = "true";
        if (recordStream !== null) {
          streamOpened(recordStream);
        } else {
          navigator.mediaDevices.getUserMedia({ audio: false, video: true }).then(streamOpened);
        }
      }
    };
  };

  window.onload = ready;
</script>
