---
import Layout from "../layouts/Layout.astro";
import Spinner from "../components/Spinner.astro";
---

<Layout class="app" title="Record ASL Word/Phrase">
  <div class="io-pane">
    <div style="display: none;" id="spinner-overlay" class="spinner-overlay">
      <Spinner id="spinner" />
    </div>
    <video id="video-output"></video>
    <div style="display: none;" id="preview-parent"></div>
  </div>
  <div class="interface">
    <div id="complete-section" style="display: none;">
      <input name="word-name" id="name-input" value="word" />
      <a id="download-link" class="as-button" href="about:blank">Download Data</a>
    </div>
    <button data-recording="false" id="record">Start Recording</button>
  </div>
</Layout>

<style>
  .app {
    display: flex;
    flex-direction: column;
    gap: var(--2);
  }

  .interface {
    display: flex;
    flex-direction: row;
    justify-content: center;
  }

  .io-pane {
    height: 40vh;
    display: flex;
    align-items: center;
    padding: var(--2);
    /* Hard-coded dark background since in light theme it's hard to see the animation */
    background-color: #14191f;
    position: relative;
  }

  .spinner-overlay {
    position: absolute;
    z-index: 10;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .spinner-overlay > #spinner {
    font-size: var(--4);
    margin: auto;
  }

  #preview-parent {
    width: 100%;
    height: 100%;
  }

  video {
    height: 100%;
    margin: 0 auto;
    border-radius: var(--1);
  }
</style>

<script>
  import { decodeMultiStream, encode } from "@msgpack/msgpack";
  import {
    type WordData,
    type Frame,
    prepareCanvas,
    renderAsl,
    type TranslationRequest,
  } from "../lib/asl-render";

  const VIDEO_MIME = "video/webm";

  const backendHost = import.meta.env.PUBLIC_BACKEND_HOST ?? "";
  const markEndpoint = `${backendHost}/api/mark`;

  const processVideo = async (rawFrames: Blob[]): Promise<WordData | null> => {
    const resp = await fetch(markEndpoint, {
      method: "POST",
      body: new Blob(rawFrames),
      headers: { "Content-Type": VIDEO_MIME },
    });
    if (resp.ok && resp.body !== null) {
      const frames = [];
      for await (const frame of decodeMultiStream(resp.body)) {
        frames.push(frame as Frame);
      }
      console.debug("Got frames", frames.length);
      return frames;
    } else {
      // TODO: Error Handle
      console.error(resp);
      return null;
    }
  };

  const ready = () => {
    const videoElem = document.getElementById("video-output")! as HTMLVideoElement;
    const recordButton = document.getElementById("record")! as HTMLButtonElement;
    const downloadLink = document.getElementById("download-link")! as HTMLAnchorElement;
    const previewCanvas = document.getElementById("preview-parent")! as HTMLDivElement;
    const completeSection = document.getElementById("complete-section")! as HTMLDivElement;
    const nameInput = document.getElementById("name-input")! as HTMLInputElement;
    const spinnerElem = document.getElementById("spinner-overlay")! as HTMLSpanElement;

    let isRecording = false;
    let stopping = false;

    let recordStream: MediaStream | null = null;

    const afterRecord = async (rawData: Blob[]) => {
      recordButton.disabled = true;
      recordButton.style.display = "none";
      videoElem.style.display = "none";
      spinnerElem.style.display = "flex";
      const wordData = await processVideo(rawData);
      if (wordData !== null) {
        previewCanvas.style.display = "block";
        const req = {
          words: ["rec"],
          dataMap: { rec: wordData },
        } as TranslationRequest;
        const threeCtx = prepareCanvas(previewCanvas);
        renderAsl(threeCtx, req);
        const msgPackData = encode(wordData);
        downloadLink.href = URL.createObjectURL(new Blob([msgPackData]));
        downloadLink.download = "word.msgpack";
        spinnerElem.style.display = "none";
        completeSection.style.display = "block";
        nameInput.onchange = (e) => {
          downloadLink.download = `${(e.target! as HTMLInputElement).value}.msgpack`;
        };
      } else {
        console.error("wordData is null!");
      }
    };

    const streamOpened = (stream: MediaStream) => {
      const options = { mimeType: VIDEO_MIME };
      const recordedData: Blob[] = [];
      const recorder = new MediaRecorder(stream, options);
      videoElem.srcObject = stream;
      videoElem.play();

      const onData = (e: MediaRecorderEventMap["dataavailable"]) => {
        if (e.data.size > 0) {
          recordedData.push(e.data);
        }

        if (stopping && isRecording) {
          recorder.stop();
          stopping = false;
        }
      };

      const onStopped = () => {
        isRecording = false;
        stream.getTracks().forEach((t) => t.stop());
        afterRecord(recordedData);
      };

      recorder.addEventListener("dataavailable", onData);
      recorder.addEventListener("stop", onStopped);
      isRecording = true;

      recorder.start(500);
    };

    recordButton.onclick = () => {
      if (isRecording) {
        recordButton.innerText = "Start Recording";
        recordButton.dataset["recording"] = "false";
        stopping = true;
      } else {
        recordButton.dataset["recording"] = "true";
        recordButton.innerText = "Stop Recording";
        if (recordStream !== null) {
          streamOpened(recordStream);
        } else {
          navigator.mediaDevices.getUserMedia({ audio: false, video: true }).then(streamOpened);
        }
      }
    };
  };

  window.onload = ready;
</script>
